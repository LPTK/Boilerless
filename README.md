<!-- # Boilerless: a minimalist library to facilitate writing GADTs in Scala -->
# Boilerless: Beautiful Syntax for Case Class Hierarchies


## Introduction

Boilerless is a small utility that lets you write case class hierarchies
with a lightweight syntax closer to other functional languages.
It has special support for Generalized Algebraic Data Types (GADT) and enums-like hierarchies.

Following is a short example showing how to write an `EitherOrBoth` data type.
The precise rules used to expand it are explained further below.

```scala
@enum class EitherOrBoth[+A,+B] {
  def fold[T](f: A => T, g: B => T): Either[T, (T,T)]
  
  // Cases:
  class Left[A](value: A) { fold(f,g) = Left(f(value)) } 
  class Right[B](value: B) { fold(f,g) = Left(g(value)) }
  class Both[_](left: A, right: B) { fold(f,g) = Right(f(left), g(right)) }
}
```

Boilerless is based on [macro annotations](http://docs.scala-lang.org/overviews/macros/annotations.html),
which will expand at compile time into proper Scala code.
The code above will generate the equivalent of:

```scala
sealed abstract class EitherOrBoth[+A, +B] {
  def fold[T](f: A => T, g: B => T): Either[T, (T,T)]
}
object EitherOrBoth {
  // Cases:
  case class Left[A](value: A) extends EitherOrBoth[A, Nothing] {
    def fold[T](f: A => T, g: Nothing => T): Either[T, (T,T)] = Left(f(value))
  }
  case class Right[B](value: B) extends EitherOrBoth[Nothing, B] {
    def fold[T](f: Nothing => T, g: B => T): Either[T, (T,T)] = Left(g(value))
  }
  case class Both[+A, +B](left: A, right: B) extends EitherOrBoth[A, B] {
    def fold[T](f: A => T, g: Nothing => T): Either[T, (T,T)] =
      Right(f(left), g(right))
  }
}
```

**Note:** Macro annotations are not _officially_ supported in Scala, and their syntax highlighting will be broken in most IDE's.
However, Boilerless offers [alternatives](#IDE-Integration-and-Def-Macro-Implementation) to circumvent these problems.


## Functionalities

### Enums

<!-- If the parameters to be passed to the -->
As seen above, type and term parameters can be passed from case classes to the parent class implicitly
using the lightweight `_[..types](...args)` syntax inside the body of the case class.
Moreover, if that is the very first expression in the body and there are no types to pass,
the `_` can be ommitted. Therefore, one can write:
<!-- if that is the only expression  -->

```scala
@enum class State(entryName: String) {
   object Alabama{"AL"}
   object Alaska{"AK"}
   
   object California { _("CA") }  // explicit initialization syntax
   
   // and so on and so forth.
}
```

Boilerless has special support for [enumeratum](http://github.com/lloydmeta/enumeratum).
By only changing `@enum` to `@enumeratum` in the code above,
the parent class is made to extend `enumeratum.EnumEntry`,
the case classes to extend `enumeratum.Enum[State]`,
and a `val values = findValues` field is added to the companion object:

```scala
@enumeratum class State(entryName: String) {
   object Alabama {"AL"}
   object Alaska {"AK"}
   // and so on and so forth.
}
assert(State.withName("AL") == State.Alabama)
```

You can see the code generated by the definitions above
[here](core/src/test/scala/boilerless/EnumeratumTests.scala#L12).



### Type Parameter Forwarding

As shown in the `EitherOrBoth` example above,
if there is no explicit `extends Parent[..](...)` clause or `_[..](...)` initialization call, 
type parameters named the same as type parameters of the parent class are forwarded automatically.
Bounds and variance annotations for these parameters do not need to be repeated,
as they are copied from the parent class.
Parent type parameters not mentioned in the case class are passed to the parent class
as the lower bound if the parameter is covariant, the upper bound if it is contravariant,
and an existential otherwise.

One can also import all parent parameters with syntax `[_, ..]`,
i.e., first parameter named underscore `_`, possibly followed by more parameters.



### Nested Hierarchies

Nested hierarchies are naturally supported,
as macro annotations expand from the outermost to the innermost definition.
The following:

```scala
@enum class Level0(x: Int) {
  class Sub0{0}
  class Sub1(x: Int){x}
  @enum class Level1(x: Int) { _(x)
    class SubSub0{1}
    class SubSub1(y: Int){y}
  }
}
```
... generates:
```scala
sealed abstract class Level0(x: Int)
object Level0 {
  case class Sub0() extends Level0(0)
  case class Sub1(x: Int) extends Level0(x)
  @enum case class Level1(x: Int) extends Level0(x) {
    class SubSub0 {1}
    class SubSub1(y: Int) {y}
  }
}
```
... which in turn generates:

```scala
sealed abstract class Level0(x: Int)
object Level0 {
  case class Sub0() extends Level0(0)
  case class Sub1(x: Int) extends Level0(x)
  sealed abstract class Level1(x: Int) extends Level0(x)
  object Level1 {
    case class SubSub0() extends Level1(1)
    case class SubSub1(y: Int) extends Level1(y)
  }
}
```



## IDE Integration and Def Macro Implementation

Boilerless provides a `@enumInFile(fileName, package)` macro that,
instead of expanding into the class trees, will write the result to a new Scala file [1].
The new file will be placed in `$fileName/ClassName.scala`, its package will be `$package`,
and imports found at macro call site will be placed at the top.

Arguments `fileName` and `package` have to be string literals.
It is advised to set `fileName` to a folder belonging to a subproject
that depends on the project containing the `@enum` class, and _not the same project_.
This way, whenever you change the `@enum` class, it will re-expand first,
writing the result in the file located in the dependent project,
and that file will then be compiled whith the dependent project.
<!-- If it was in the same project, you would have to compile twice. -->

**Note:** You may still have to compile twice,
unless you use a special configuration or command
to explicitly ask `sbt` to compile the project containing the templates first,
like `sbt templates-project/compile main-project/run`.

If you do not want to use macro annotations,
a [def macro](http://docs.scala-lang.org/overviews/macros/overview.html)
version is also available as `genEnum(fileName, package)(){""" code """}`.

This functionality has only been tested with sbt `0.13.8` and Scala `2.11.8`.
It is known not to work in IntelliJ
(but a mere warning will be raised and the macro failure will not stop compilation).

[1] Something macros are not _supposed_ to do, but is very useful.





## Custom Options

Several options can be passed to `@enum` in order to customize its behavior.

 - `'Unseal` will prevent making the `@enum` class sealed. 
 
 - `'Debug` enables debugging output,
 and allows to see what is generated by the macro expansion.

For example: `@enum('Unseal, 'Debug) class Enum { ... }`.

Annotate with `@ignore` a member definition to leave it untouched by Boilerless.

In addition, arbitrary classes, methods and objects (even outside of `@enum` hierarchies) 
may be modified after the fact with: 
 
 - `@notCase` to cancel a `case` modifier

 - `@open` to cancel a `final` or `sealed` modifier

 - `@concrete` to cancel an `abstract` modifier



## Known Limitations

### Syntax-Driven

Boilerless is completely syntax-driven,
as it operate before type-checking and name resolution.
As a consequence, if you extend the _parent class_ explicitly with `extends Base[..](...)`,
it is important to do so with the bare parent name (so Boilerless can detect it),
and not something like `extends my.package.Base[..](...)`.
<!-- As a consequence, it is important to use
`@enum` for nested enums (and not `@boilerless.enum`, for example).-->


### IDE support

IDE's will likely not understand Boilerless' syntax and semantics,
so it may be good to turn inspections off for the specific definition file.
See also [this](#IDE-Integration-and-Def-Macro-Implementation) to circumvent the problem.



